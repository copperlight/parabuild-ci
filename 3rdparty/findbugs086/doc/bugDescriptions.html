<html><head><title>FindBugs Bug Descriptions</title>
<link rel="stylesheet" type="text/css" href="findbugs.css">
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
</head><body>

<table width="100%"><tr>

<td bgcolor="#b9b9fe" valign="top" align="left" width="20%"> 
<table width="100%" cellspacing="0" border="0"> 
<tr><td><a class="sidebar" href="index.html"><b>FindBugs</b></a></td></tr> 

<tr><td>&nbsp;</td></tr>

<tr><td><b>Docs and Info</b></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="factSheet.html">Fact sheet</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="manual/index.html">Manual (en)</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="http://www.simeji.com/findbugs/doc/manual_ja/index.html">Manual (ja)</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="FAQ.html">FAQ</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="bugDescriptions.html">Bug descriptions</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="mailingLists.html">Mailing lists</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="publications.html">Documents and Publications</a></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="links.html">Links</a></td></tr> 

<tr><td>&nbsp;</td></tr>

<tr><td><a class="sidebar" href="http://sourceforge.net/project/showfiles.php?group_id=96405"><b>Downloads</b></a></td></tr> 

<tr><td>&nbsp;</td></tr>

<tr><td><a class="sidebar" href="http://www.cafeshops.com/findbugs"><b>FindBugs Swag</b></a></td></tr>

<tr><td>&nbsp;</td></tr>

<tr><td><b>Development</b></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="reportingBugs.html">Reporting bugs</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="contributing.html">Contributing</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="team.html">Dev team</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="Changes.html">Change log</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="http://sourceforge.net/projects/findbugs">SF project page</a></font></td></tr> 
<tr><td><font size="-1"><a class="sidebar" href="http://cvs.sourceforge.net/viewcvs.py/findbugs">Browse source</a></font></td></tr> 
</table> 
</td>
<td align="left" valign="top">
<h1>FindBugs Bug Descriptions</h1>
<p>This document lists the standard bug patterns reported by
<a href="http://findbugs.sourceforge.net">FindBugs</a> version 0.8.6.</p>
<h2>Summary</h2>
<table width="100%">
<tr bgcolor="#b9b9fe"><th>Description</th><th>Category</th></tr>
<tr bgcolor="#eeeeee"><td><a href="#AM_CREATES_EMPTY_JAR_FILE_ENTRY">AM: Creates an empty jar file entry</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#AM_CREATES_EMPTY_ZIP_FILE_ENTRY">AM: Creates an empty zip file entry</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#BIT_AND">BIT: Incompatible bit masks</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#BIT_AND_ZZ">BIT: Incompatible bit masks</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#BIT_IOR">BIT: Incompatible bit masks</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#BOA_BADLY_OVERRIDDEN_ADAPTER">BOA: Class overrides a method implemented in super class Adapter wrongly</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#BRSA_BAD_RESULTSET_ACCESS">BRSA: Method attempts to access a result set field with index 0</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#CN_IDIOM">CN: Class implements Cloneable but does not define or use clone method</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#CN_IDIOM_NO_SUPER_CALL">CN: clone method does not call super.clone()</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#CO_ABSTRACT_SELF">Co: Abstract class defines covariant compareTo() method</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#CO_SELF_NO_OBJECT">Co: Covariant compareTo() method defined</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#DE_MIGHT_DROP">DE: Method might drop exception</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#DE_MIGHT_IGNORE">DE: Method might ignore exception</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#DLS_DEAD_LOCAL_STORE">DLS: Dead store to local variable</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#DM_EXIT">Dm: Method invokes System.exit(...)</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#DM_USELESS_THREAD">Dm: A thread was created using the default empty run method</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#EC_NULL_ARG">EC: Call to equals() with null argument</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#EC_UNRELATED_INTERFACES">EC: Call to equals() comparing different interface types</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#EC_UNRELATED_TYPES">EC: Call to equals() comparing different types</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#ES_COMPARING_STRINGS_WITH_EQ">ES: Comparison of String objects using == or !=</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#EQ_ABSTRACT_SELF">Eq: Abstract class defines covariant equals() method</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#EQ_SELF_NO_OBJECT">Eq: Covariant equals() method defined</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#EQ_SELF_USE_OBJECT">Eq: Covariant equals() method defined, Object.equals(Object) inherited</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#FI_EXPLICIT_INVOCATION">FI: Explicit invocation of finalizer</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#FI_MISSING_SUPER_CALL">FI: Finalizer does not call superclass finalizer</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#FI_NULLIFY_SUPER">FI: Finalizer nullifies superclass finalizer</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#HE_EQUALS_NO_HASHCODE">HE: Class defines equals() but not hashCode()</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#HE_EQUALS_USE_HASHCODE">HE: Class defines equals() and uses Object.hashCode()</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#HE_HASHCODE_NO_EQUALS">HE: Class defines hashCode() but not equals()</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#HE_HASHCODE_USE_OBJECT_EQUALS">HE: Class defines hashCode() and uses Object.equals()</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#HE_INHERITS_EQUALS_USE_HASHCODE">HE: Class inherits equals() and uses Object.hashCode()</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#IC_INIT_CIRCULARITY">IC: Initialization circularity</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#IJU_SETUP_NO_SUPER">IJU: TestCase implements setUp but doesn't call super.setUp()</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#IL_INFINITE_RECURSIVE_LOOP">IL: An apparent infinite recursive loop.</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#IMSE_DONT_CATCH_IMSE">IMSE: Dubious catching of IllegalMonitorStateException</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">IP: A parameter is dead upon entry to a method but 
	overwritten</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#IT_NO_SUCH_ELEMENT">It: Iterator next() method can't throw NoSuchElement exception</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#MF_CLASS_MASKS_FIELD">MF: Class defines field that obscures a superclass field</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#MF_METHOD_MASKS_FIELD">MF: Method defines a variable that obscures a field</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#MWN_MISMATCHED_NOTIFY">MWN: Mismatched notify()</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#MWN_MISMATCHED_WAIT">MWN: Mismatched wait()</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#NP_ALWAYS_NULL">NP: Null pointer dereference in method</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#NP_ALWAYS_NULL_EXCEPTION">NP: Null pointer dereference in method on exception path</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#NP_NULL_ON_SOME_PATH">NP: Possible null pointer dereference in method</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#NP_NULL_ON_SOME_PATH_EXCEPTION">NP: Possible null pointer dereference in method on exception path</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#NS_NON_SHORT_CIRCUIT">NS: Questionable use of non-short-circuit logic</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#NM_BAD_EQUAL">Nm: Class defines equal(); should it be equals()?</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#NM_CONFUSING">Nm: Confusing method names</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#NM_CONFUSING_METHOD_NAME">Nm: Confusing method name</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#NM_LCASE_HASHCODE">Nm: Class defines hashcode(); should it be hashCode()?</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#NM_LCASE_TOSTRING">Nm: Class defines tostring(); should it be toString()?</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#NM_VERY_CONFUSING">Nm: Very confusing method names</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#ODR_OPEN_DATABASE_RESOURCE">ODR: Method may fail to close database resource</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">ODR: Method may fail to close database resource on exception</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#OS_OPEN_STREAM">OS: Method may fail to close stream</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#OS_OPEN_STREAM_EXCEPTION_PATH">OS: Method may fail to close stream on exception</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#PZLA_PREFER_ZERO_LENGTH_ARRAYS">PZLA: Consider returning a zero length array rather than null</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#RC_REF_COMPARISON">RC: Suspicious reference comparison</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#RCN_REDUNDANT_CHECKED_NULL_COMPARISION">RCN: Redundant comparision to null of previously checked value</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#RCN_REDUNDANT_COMPARISON_TO_NULL">RCN: Redundant comparison to null</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#RR_NOT_CHECKED">RR: Method ignores results of InputStream.read()</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SR_NOT_CHECKED">RR: Method ignores results of InputStream.skip()</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#RV_RETURN_VALUE_IGNORED">RV: Method ignores return value</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SA_FIELD_SELF_ASSIGNMENT">SA: Self assignment of field</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#SI_INSTANCE_BEFORE_FINALS_ASSIGNED">SI: Static initializer for class creates instance before all static final fields assigned</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SIO_SUPERFLUOUS_INSTANCEOF">SIO: Unnecessary type check done using instanceof operator</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">SW: Certain swing methods should only be invoked from the Swing event thread</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SE_BAD_FIELD">Se: Non-transient non-serializable instance field in serializable class</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#SE_NONFINAL_SERIALVERSIONID">Se: serialVersionUID isn't final</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SE_NONLONG_SERIALVERSIONID">Se: serialVersionUID isn't long</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#SE_NONSTATIC_SERIALVERSIONID">Se: serialVersionUID isn't static</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SE_NO_SUITABLE_CONSTRUCTOR">Se: Class is Serializable but its superclass doesn't define a void constructor</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">Se: Class is Externalizable but doesn't define a void constructor</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SE_NO_SERIALVERSIONID">SnVI: Class is Serializable, but doesn't define serialVersionUID</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#TESTING">TEST: Testing</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#UCF_USELESS_CONTROL_FLOW">UCF: Useless control flow in method</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#UI_INHERITANCE_UNSAFE_GETRESOURCE">UI: Usage of GetResource may be unsafe if class is extended</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#UOE_BAD_ARRAY_COMPARE">UOE: Calls to equals on an Array equates to ==</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#UOE_USE_OBJECT_EQUALS">UOE: Calls to equals on a final class that doesn't override Object's version</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#UR_UNINIT_READ">UR: Uninitialized read of field in constructor</a></td><td>Correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#UWF_UNWRITTEN_FIELD">UwF: Unwritten field</a></td><td>Correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#DM_CONVERT_CASE">Dm: Method invokes dubious String.toUpperCase() or String.toLowerCase; use the Locale parameterized version instead</a></td><td>Internationalization</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#EI_EXPOSE_REP">EI: Method may expose internal representation by returning reference to mutable object</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#ffffff"><td><a href="#EI_EXPOSE_REP2">EI2: Method may expose internal representation by incorporating reference to mutable object</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#FI_PUBLIC_SHOULD_BE_PROTECTED">FI: Finalizer should be protected, not public</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#ffffff"><td><a href="#EI_EXPOSE_STATIC_REP2">MS: Method may expose internal static state by storing a mutable object into a static field</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#MS_CANNOT_BE_FINAL">MS: Field isn't final and can't be protected from malicious code</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#ffffff"><td><a href="#MS_EXPOSE_REP">MS: Public static method may expose internal representation by returning array</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#MS_FINAL_PKGPROTECT">MS: Field should be both final and package protected</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#ffffff"><td><a href="#MS_MUTABLE_ARRAY">MS: Field is a mutable array</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#MS_MUTABLE_HASHTABLE">MS: Field is a mutable Hashtable</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#ffffff"><td><a href="#MS_OOI_PKGPROTECT">MS: Field should be moved out of an interface and made package protected</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#MS_PKGPROTECT">MS: Field should be package protected</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#ffffff"><td><a href="#MS_SHOULD_BE_FINAL">MS: Field isn't final but should be</a></td><td>Malicious code vulnerability</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#2LW_TWO_LOCK_WAIT">2LW: Wait with two locks held</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#DC_DOUBLECHECK">DC: Possible double check of field</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#IS2_INCONSISTENT_SYNC">IS2: Inconsistent synchronization</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#LI_LAZY_INIT_STATIC">LI: Incorrect lazy initialization of static field</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#ML_SYNC_ON_UPDATED_FIELD">ML: Method synchronizes on an updated field</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#NN_NAKED_NOTIFY">NN: Naked notify in method</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#NO_NOTIFY_NOT_NOTIFYALL">No: Using notify() rather than notifyAll() in method</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#RS_READOBJECT_SYNC">RS: Class's readObject() method is synchronized</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#RU_INVOKE_RUN">Ru: Invokes run on a thread (did you mean to start it instead?)</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SC_START_IN_CTOR">SC: Constructor invokes Thread.start()</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#SP_SPIN_ON_FIELD">SP: Method spins on field</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#UG_SYNC_SET_UNSYNC_GET">UG: Unsynchronized get method, synchronized set method</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#UW_UNCOND_WAIT">UW: Unconditional wait in method</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#VO_VOLATILE_REFERENCE_TO_ARRAY">VO: A volatile reference to an array doesn't treat the array elements as volatile</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#WS_WRITEOBJECT_SYNC">WS: Class's writeObject() method is synchronized but nothing else is</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#ffffff"><td><a href="#WA_NOT_IN_LOOP">Wa: Wait not in loop in method</a></td><td>Multithreaded correctness</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#DM_BOOLEAN_CTOR">Dm: Method invokes dubious Boolean constructor; use Boolean.valueOf(...) instead</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#DM_BOXED_PRIMITIVE_TOSTRING">Dm: Method allocates a boxed primitive just to call toString</a></td><td>Performance</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#DM_GC">Dm: Explicit garbage collection; extremely dubious except in benchmarking code</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#DM_NEW_FOR_GETCLASS">Dm: Method allocates an object, only to get the class object</a></td><td>Performance</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#DM_NEXTINT_VIA_NEXTDOUBLE">Dm: Use the nextInt method of Random rather than nextDouble to generate a random integer</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#DM_STRING_CTOR">Dm: Method invokes dubious new String(String) constructor; just use the argument</a></td><td>Performance</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#DM_STRING_EMPTY_EQUALS">Dm: Method invokes dubious String.equals(""); use String.length() == 0 instead</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#DM_STRING_TOSTRING">Dm: Method invokes toString() method on a String; just use the String</a></td><td>Performance</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#DM_STRING_VOID_CTOR">Dm: Method invokes dubious new String() constructor; just use ""</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#FI_EMPTY">FI: Empty finalizer should be deleted</a></td><td>Performance</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#FI_USELESS">FI: Finalizer does nothing but call superclass finalizer</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#ITA_INEFFICIENT_TO_ARRAY">ITA: Method uses toArray() with zero-length array argument</a></td><td>Performance</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#SBSC_USE_STRINGBUFFER_CONCATENATION">SBSC: Method concatenates strings using + in a loop</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SIC_INNER_SHOULD_BE_STATIC">SIC: Should be a static inner class</a></td><td>Performance</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#SIC_INNER_SHOULD_BE_STATIC_ANON">SIC: Could be refactored into a named static inner class</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">SIC: Could be refactored into a static inner class</a></td><td>Performance</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#SS_SHOULD_BE_STATIC">SS: Unread field: should this field be static?</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#UPM_UNCALLED_PRIVATE_METHOD">UPM: Private method is never called</a></td><td>Performance</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#URF_UNREAD_FIELD">UrF: Unread field</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#UUF_UNUSED_FIELD">UuF: Unused field</a></td><td>Performance</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#WMI_WRONG_MAP_ITERATOR">WMI: Inefficient use of keySet iterator instead of entrySet iterator</a></td><td>Performance</td></tr>
<tr bgcolor="#ffffff"><td><a href="#NM_CLASS_NAMING_CONVENTION">Nm: Class names should start with an upper case letter</a></td><td>Style</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#NM_FIELD_NAMING_CONVENTION">Nm: Field names should start with an lower case letter</a></td><td>Style</td></tr>
<tr bgcolor="#ffffff"><td><a href="#NM_METHOD_NAMING_CONVENTION">Nm: Method names should start with an lower case letter</a></td><td>Style</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#REC_CATCH_EXCEPTION">REC: java.lang.Exception is caught when Exception is not thrown</a></td><td>Style</td></tr>
<tr bgcolor="#ffffff"><td><a href="#SA_LOCAL_SELF_ASSIGNMENT">SA: Self assignment of local variable</a></td><td>Style</td></tr>
<tr bgcolor="#eeeeee"><td><a href="#SF_SWITCH_FALLTHROUGH">SF: A switch statement found where one case falls thru to the next case</a></td><td>Style</td></tr>
</table>
<h2>Descriptions</h2>
<h3><a name="AM_CREATES_EMPTY_JAR_FILE_ENTRY">AM: Creates an empty jar file entry</a></h3>


<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>. This results
in an empty JarFile entry. The contents of the entry
should be written to the JarFile between the calls to 
<code>putNextEntry()</code> and
<code>closeEntry()</code>.</p>

    
<h3><a name="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">AM: Creates an empty zip file entry</a></h3>


<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>. This results
in an empty ZipFile entry. The contents of the entry
should be written to the ZipFile between the calls to 
<code>putNextEntry()</code> and
<code>closeEntry()</code>.</p>

    
<h3><a name="BIT_AND">BIT: Incompatible bit masks</a></h3>


<p> This method compares an expression of the form (a &amp; C) to D,
which will always compare unequal
due to the specific values of constants C and D.
This may indicate a logic error or typo.</p>

    
<h3><a name="BIT_AND_ZZ">BIT: Incompatible bit masks</a></h3>


<p> This method compares an expression of the form (a &amp; 0) to 0,
which will always compare equal.
This may indicate a logic error or typo.</p>

    
<h3><a name="BIT_IOR">BIT: Incompatible bit masks</a></h3>


<p> This method compares an expression of the form (a | C) to D.
which will always compare unequal
due to the specific values of constants C and D.
This may indicate a logic error or typo.</p>

<p> Typically, this bug occurs because the code wants to perform
a membership test in a bit set, but uses the bitwise OR
operator ("|") instead of bitwise AND ("&amp;").</p>

    
<h3><a name="BOA_BADLY_OVERRIDDEN_ADAPTER">BOA: Class overrides a method implemented in super class Adapter wrongly</a></h3>


<p> This method overrides a method found in a parent class, where that class is an Adapter that implements
a listener defined in the java.awt.event or javax.swing.event package. As a result, this method will not 
get called when the event occurs.</p>

    
<h3><a name="BRSA_BAD_RESULTSET_ACCESS">BRSA: Method attempts to access a result set field with index 0</a></h3>


<p> A call to getXXX or updateXXX methods of a result set was made where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake.</p>

    
<h3><a name="CN_IDIOM">CN: Class implements Cloneable but does not define or use clone method</a></h3>


<p>
	Class implements Cloneable but does not define or
	use the clone method.</p>

    
<h3><a name="CN_IDIOM_NO_SUPER_CALL">CN: clone method does not call super.clone()</a></h3>


<p> This class defines a clone() method that does not call super.clone(),
and is not final.
If this class ("<i>A</i>") is extended by a subclass ("<i>B</i>"),
and the subclass <i>B</i> calls super.clone(), then it is likely that
<i>B</i>'s clone() method will return an object of type <i>A</i>,
which violates the standard contract for clone().</p>

<p> If all clone() methods call super.clone(), then they are guaranteed
to use Object.clone(), which always returns an object of the correct type.</p>

    
<h3><a name="CO_ABSTRACT_SELF">Co: Abstract class defines covariant compareTo() method</a></h3>


  <p> This class defines a covariant version of <code>compareTo()</code>.&nbsp;
  To correctly override the <code>compareTo()</code> method in the
  <code>Comparable</code> interface, the parameter of <code>compareTo()</code>
  must have type <code>java.lang.Object</code>.</p>

    
<h3><a name="CO_SELF_NO_OBJECT">Co: Covariant compareTo() method defined</a></h3>


  <p> This class defines a covariant version of <code>compareTo()</code>.&nbsp;
  To correctly override the <code>compareTo()</code> method in the
  <code>Comparable</code> interface, the parameter of <code>compareTo()</code>
  must have type <code>java.lang.Object</code>.</p>

    
<h3><a name="DE_MIGHT_DROP">DE: Method might drop exception</a></h3>


  <p> This method might drop an exception.&nbsp; In general, exceptions
  should be handled or reported in some way, or they should be thrown
  out of the method.</p>

    
<h3><a name="DE_MIGHT_IGNORE">DE: Method might ignore exception</a></h3>


  <p> This method might ignore an exception.&nbsp; In general, exceptions
  should be handled or reported in some way, or they should be thrown
  out of the method.</p>

    
<h3><a name="DLS_DEAD_LOCAL_STORE">DLS: Dead store to local variable</a></h3>


<p>
This instruction assigns a value to a local variable,
but the value is not read by any subsequent instruction.
Often, this indicates an error, because the value computed 
is never used.
</p>

    
<h3><a name="DM_EXIT">Dm: Method invokes System.exit(...)</a></h3>


  <p> Invoking System.exit shuts down the entire Java virtual machine. This
	should only been done when it is appropriate. Such calls make it 
	hard or impossible for your code to be invoked by other code.
	Consider throwing a RuntimeException instead.</p>

    
<h3><a name="DM_USELESS_THREAD">Dm: A thread was created using the default empty run method</a></h3>


  <p>This method creates a thread without specifying a run method either by deriving from the Thread class, or 
  by passing a Runnable object. This thread, then, does nothing but waste time.
</p>

    
<h3><a name="EC_NULL_ARG">EC: Call to equals() with null argument</a></h3>


<p> This method calls equals(Object), passing a null value as
the argument. According to the contract of the equals() method,
this call should always return <code>false</code>.</p>

    
<h3><a name="EC_UNRELATED_INTERFACES">EC: Call to equals() comparing different interface types</a></h3>


<p> This method calls equals(Object) on two references of unrelated
interface types (neither is a subtype of the other).  According to
the contract of equals(), objects of different classes should always
compare as unequal. Note that it is possible that
the program contains classes that implement both interfaces,
so the comparison may be valid.  However, it is worth
inspecting closely.</p>

    
<h3><a name="EC_UNRELATED_TYPES">EC: Call to equals() comparing different types</a></h3>


<p> This method calls equals(Object) on two references of different
types.  According to the contract of equals(), objects of different
classes should always compare as unequal; therefore, it is likely
that the result of this comparision will always be false at runtime.</p>

    
<h3><a name="ES_COMPARING_STRINGS_WITH_EQ">ES: Comparison of String objects using == or !=</a></h3>


  <p>This code compares <code>java.lang.String</code> objects for reference
equality using the == or != operators.
Unless both strings are either constants in a source file, or have been
interned using the <code>String.intern()</code> method, the same string
value may be represented by two different String objects. Consider
using the <code>equals(Object)</code> method instead.</p>

    
<h3><a name="EQ_ABSTRACT_SELF">Eq: Abstract class defines covariant equals() method</a></h3>


  <p> This class defines a covariant version of <code>equals()</code>.&nbsp;
  To correctly override the <code>equals()</code> method in
  <code>java.lang.Object</code>, the parameter of <code>equals()</code>
  must have type <code>java.lang.Object</code>.</p>

    
<h3><a name="EQ_SELF_NO_OBJECT">Eq: Covariant equals() method defined</a></h3>


  <p> This class defines a covariant version of <code>equals()</code>.&nbsp;
  To correctly override the <code>equals()</code> method in
  <code>java.lang.Object</code>, the parameter of <code>equals()</code>
  must have type <code>java.lang.Object</code>.</p>

    
<h3><a name="EQ_SELF_USE_OBJECT">Eq: Covariant equals() method defined, Object.equals(Object) inherited</a></h3>


  <p> This class defines a covariant version of the <code>equals()</code>
  method, but calls the normal <code>equals(Object)</code> method
  defined in the base <code>java.lang.Object</code> class.&nbsp;
  The class should probably define a non-covariant version of <code>equals()</code>.&nbsp;
  (I.e., a method with the signature <code>boolean equals(java.lang.Object)</code>.</p>

    
<h3><a name="FI_EXPLICIT_INVOCATION">FI: Explicit invocation of finalizer</a></h3>


  <p> This method contains an explicit invocation of the <code>finalize()</code>
  method on an object.&nbsp; Because finalizer methods are supposed to be
  executed once, and only by the VM, this is a bad idea.</p>

    
<h3><a name="FI_MISSING_SUPER_CALL">FI: Finalizer does not call superclass finalizer</a></h3>


  <p> This <code>finalize()</code> method does not make a call to its
  superclass's <code>finalize()</code> method.&nbsp; So, any finalizer
  actions defined for the superclass will not be performed.&nbsp;
  Add a call to <code>super.finalize()</code>.</p>

    
<h3><a name="FI_NULLIFY_SUPER">FI: Finalizer nullifies superclass finalizer</a></h3>


  <p> This empty <code>finalize()</code> method explicitly negates the
  effect of any finalizer defined by its superclass.&nbsp; Any finalizer
  actions defined for the superclass will not be performed.&nbsp;
  Unless this is intended, delete this method.</p>

    
<h3><a name="HE_EQUALS_NO_HASHCODE">HE: Class defines equals() but not hashCode()</a></h3>


  <p> This class overrides <code>equals(Object)</code>, but does not
  override <code>hashCode()</code>.&nbsp; Therefore, the class may violate the
  invariant that equal objects must have equal hashcodes.</p>

    
<h3><a name="HE_EQUALS_USE_HASHCODE">HE: Class defines equals() and uses Object.hashCode()</a></h3>


  <p> This class overrides <code>equals(Object)</code>, but does not
  override <code>hashCode()</code>, and inherits the implementation of
  <code>hashCode()</code> from <code>java.lang.Object</code> (which returns
  the identity hash code, an arbitrary value assigned to the object
  by the VM).&nbsp; Therefore, the class is very likely to violate the
  invariant that equal objects must have equal hashcodes.</p>

  <p>If you don't want to define a hashCode method, and/or don't
	believe the object will ever be put into a HashMap/Hashtable,
	define the <code>hashCode()</code> method
	to throw <code>UnsupportedOperationException</code>.</p>

    
<h3><a name="HE_HASHCODE_NO_EQUALS">HE: Class defines hashCode() but not equals()</a></h3>


  <p> This class defines a <code>hashCode()</code> method but not an
  <code>equals()</code> method.&nbsp; Therefore, the class may
  violate the invariant that equal objects must have equal hashcodes.</p>

    
<h3><a name="HE_HASHCODE_USE_OBJECT_EQUALS">HE: Class defines hashCode() and uses Object.equals()</a></h3>


  <p> This class defines a <code>hashCode()</code> method but inherits its
  <code>equals()</code> method from <code>java.lang.Object</code>
  (which defines equality by comparing object references).&nbsp; Although
  this will probably satisfy the contract that equal objects must have
  equal hashcodes, it is probably not what was intended by overriding
  the <code>hashCode()</code> method.&nbsp; (Overriding <code>hashCode()</code>
  implies that the object's identity is based on criteria more complicated
  than simple reference equality.)</p>

    
<h3><a name="HE_INHERITS_EQUALS_USE_HASHCODE">HE: Class inherits equals() and uses Object.hashCode()</a></h3>


  <p> This class inherits <code>equals(Object)</code> from an abstract
  superclass, and <code>hashCode()</code> from 
from <code>java.lang.Object</code> (which returns
  the identity hash code, an arbitrary value assigned to the object
  by the VM).&nbsp; Therefore, the class is very likely to violate the
  invariant that equal objects must have equal hashcodes.</p>

  <p>If you don't want to define a hashCode method, and/or don't
	believe the object will ever be put into a HashMap/Hashtable,
	define the <code>hashCode()</code> method
	to throw <code>UnsupportedOperationException</code>.</p>

    
<h3><a name="IC_INIT_CIRCULARITY">IC: Initialization circularity</a></h3>


  <p> A circularity was detected in the static initializers of the two
  classes referenced by the bug instance.&nbsp; Many kinds of unexpected
  behavior may arise from such circularity.</p>

    
<h3><a name="IJU_SETUP_NO_SUPER">IJU: TestCase implements setUp but doesn't call super.setUp()</a></h3>


<p> Class is a JUnit TestCase and implements the setUp method. The setUp method should call
super.setUp(), but doesn't.</p>

    
<h3><a name="IL_INFINITE_RECURSIVE_LOOP">IL: An apparent infinite recursive loop.</a></h3>


<p>This method unconditionally invokes itself. This would seem to indicate
an infinite recursive loop that will result in a stack overflow.</p>

    
<h3><a name="IMSE_DONT_CATCH_IMSE">IMSE: Dubious catching of IllegalMonitorStateException</a></h3>


<p>IllegalMonitorStateException is generally only
	thrown in case of a design flaw in your code (calling wait or
	notify on an object you do not hold a lock on).</p>

    
<h3><a name="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">IP: A parameter is dead upon entry to a method but 
	overwritten</a></h3>


<p>
The initial value of this parameter is ignored, and the parameter
is overwritten here. This often indicates a mistaken belief that
the write to the parameter will be conveyed back to
the caller.
</p>

    
<h3><a name="IT_NO_SUCH_ELEMENT">It: Iterator next() method can't throw NoSuchElement exception</a></h3>


  <p> This class implements the <code>java.util.Iterator</code> interface.&nbsp;
  However, its <code>next()</code> method is not capable of throwing
  <code>java.util.NoSuchElementException</code>.&nbsp; The <code>next()</code>
  method should be changed so it throws <code>NoSuchElementException</code>
  if is called when there are no more elements to return.</p>

    
<h3><a name="MF_CLASS_MASKS_FIELD">MF: Class defines field that obscures a superclass field</a></h3>


<p> This class defines a field with the same name as a visible
instance field in a superclass.  This is confusing, and
may indicate an error if methods update or access one of
the fields when they wanted the other.</p>

    
<h3><a name="MF_METHOD_MASKS_FIELD">MF: Method defines a variable that obscures a field</a></h3>


<p> This method defines a local variable with the same name as a field
in this class or a superclass.  This may cause the method to
read an uninitialized value from the field, leave the field uninitialized,
or both.</p>

    
<h3><a name="MWN_MISMATCHED_NOTIFY">MWN: Mismatched notify()</a></h3>


<p> This method calls Object.notify() or Object.notifyAll() without obviously holding a lock
on the object.&nbsp;  Calling notify() or notifyAll() without a lock held will result in
an <code>IllegalMonitorStateException</code> being thrown.</p>

    
<h3><a name="MWN_MISMATCHED_WAIT">MWN: Mismatched wait()</a></h3>


<p> This method calls Object.wait() without obviously holding a lock
on the object.&nbsp;  Calling wait() without a lock held will result in
an <code>IllegalMonitorStateException</code> being thrown.</p>

    
<h3><a name="NP_ALWAYS_NULL">NP: Null pointer dereference in method</a></h3>


<p> A null pointer is dereferenced here.&nbsp; This will lead to a 
<code>NullPointerException</code> when the code is executed.</p>

    
<h3><a name="NP_ALWAYS_NULL_EXCEPTION">NP: Null pointer dereference in method on exception path</a></h3>


<p> A pointer which is null on an exception path is dereferenced here.&nbsp;
This will lead to a <code>NullPointerException</code> when the code is executed.&nbsp;
Note that because FindBugs currently does not prune infeasible exception paths,
this may be a false warning.</p>

<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.</p>

    
<h3><a name="NP_NULL_ON_SOME_PATH">NP: Possible null pointer dereference in method</a></h3>


<p> A reference value dereferenced here might be null at runtime.&nbsp;
This may lead to a <code>NullPointerException</code> when the code is executed.</p>

    
<h3><a name="NP_NULL_ON_SOME_PATH_EXCEPTION">NP: Possible null pointer dereference in method on exception path</a></h3>


<p> A reference value which is null on some exception control path is
dereferenced here.&nbsp; This may lead to a <code>NullPointerException</code>
when the code is executed.&nbsp;
Note that because FindBugs currently does not prune infeasible exception paths,
this may be a false warning.</p>

<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.</p>

    
<h3><a name="NS_NON_SHORT_CIRCUIT">NS: Questionable use of non-short-circuit logic</a></h3>


  <p> This code seems to be using non-short-circuit logic (e.g., &amp;
or |) 
rather than short-circuit logic (&amp;&amp; or ||).
Non-short-circuit logic causes both sides of the expression
to be evaluated even when the result can be inferred from
knowing the left-hand side. This can be less efficient and
can result in errors if the left-hand side guards cases
when evaluating the right-hand side can generate an error.</p>

    
<h3><a name="NM_BAD_EQUAL">Nm: Class defines equal(); should it be equals()?</a></h3>


<p> This class defines a method <code>equal(Object)</code>.&nbsp; This method does
not override the <code>equals(Object)</code> method in <code>java.lang.Object</code>,
which is probably what was intended.</p>

    
<h3><a name="NM_CONFUSING">Nm: Confusing method names</a></h3>


  <p> The referenced methods have names that differ only by capitalization.</p>

    
<h3><a name="NM_CONFUSING_METHOD_NAME">Nm: Confusing method name</a></h3>


  <p> This method has the same name as the superclass of the class it
  is defined in.</p>

    
<h3><a name="NM_LCASE_HASHCODE">Nm: Class defines hashcode(); should it be hashCode()?</a></h3>


  <p> This class defines a method called <code>hashcode()</code>.&nbsp; This method
  does not override the <code>hashCode()</code> method in <code>java.lang.Object</code>,
  which is probably what was intended.</p>

    
<h3><a name="NM_LCASE_TOSTRING">Nm: Class defines tostring(); should it be toString()?</a></h3>


  <p> This class defines a method called <code>tostring()</code>.&nbsp; This method
  does not override the <code>toString()</code> method in <code>java.lang.Object</code>,
  which is probably what was intended.</p>

    
<h3><a name="NM_VERY_CONFUSING">Nm: Very confusing method names</a></h3>


  <p> The referenced methods have names that differ only by capitalization.</p>

    
<h3><a name="ODR_OPEN_DATABASE_RESOURCE">ODR: Method may fail to close database resource</a></h3>


<p> The method creates a database resource (such as a database connection
or row set), does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the object on all paths out of the method.&nbsp; Failure to
close database resources on all paths out of a method may
result in poor performance, and could cause the application to
have problems communicating with the database.
</p>

    
<h3><a name="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">ODR: Method may fail to close database resource on exception</a></h3>


<p> The method creates a database resource (such as a database connection
or row set), does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the object on all exception paths out of the method.&nbsp; Failure to
close database resources on all paths out of a method may
result in poor performance, and could cause the application to
have problems communicating with the database.</p>

    
<h3><a name="OS_OPEN_STREAM">OS: Method may fail to close stream</a></h3>


<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the stream on all paths out of the method.&nbsp; This may result in
a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.</p>

    
<h3><a name="OS_OPEN_STREAM_EXCEPTION_PATH">OS: Method may fail to close stream on exception</a></h3>


<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
it on all possible exception paths out of the method.&nbsp;
This may result in a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.</p>

    
<h3><a name="PZLA_PREFER_ZERO_LENGTH_ARRAYS">PZLA: Consider returning a zero length array rather than null</a></h3>


<p> It is often a better design to
return a length zero array rather than a null reference to indicate that there
are no results (i.e., an empty list of results).
This way, no explicit check for null is needed by clients of the method.</p>

<p>On the otherhand, using null to indicate 
"there is no answer to this question", then it is probably appropriate. 
For example, <code>File.listFiles()</code> returns an empty list
if given a directory containing no files, and returns null if the file
is not a directory.</p>

    
<h3><a name="RC_REF_COMPARISON">RC: Suspicious reference comparison</a></h3>


<p> This method compares two reference values using the == or != operator,
where the correct way to compare instances of this type is generally
with the equals() method.  Examples of classes which should generally
not be compared by reference are java.lang.Integer, java.lang.Float, etc.</p>

    
<h3><a name="RCN_REDUNDANT_CHECKED_NULL_COMPARISION">RCN: Redundant comparision to null of previously checked value</a></h3>


<p> This method contains a redundant comparison of a reference value
to null. Two types of redundant comparison are reported:
<ul>
<li> Both values compared are definitely null</li>
<li> One value is definitely null and the other is definitely not null</li>
</ul>
</p>

<p> This particular warning generally indicates that a
value known not to be null was checked against null.
While the check is not necessary, it may simply be a case
of defensive programming.</p>

    
<h3><a name="RCN_REDUNDANT_COMPARISON_TO_NULL">RCN: Redundant comparison to null</a></h3>


<p> This method contains a redundant comparison of a reference value
to null. Two types of redundant comparison are reported:
<ul>
<li> Both values compared are definitely null</li>
<li> One value is definitely null and the other is definitely not null</li>
</ul>
</p>

<p> This particular warning represents two specific kinds of
redundant comparisions:
<ol>
<li> A value was dereferenced, and later explicitly compared to null:
     this often indicates an error in the method</li>
<li> A literal null value was explicitly compared to null:
     this may indicate that the method was modified without
     complete understanding of the invariants of the method</li>
</ol>
</p>

    
<h3><a name="RR_NOT_CHECKED">RR: Method ignores results of InputStream.read()</a></h3>


  <p> This method ignores the return value of one of the variants of
  <code>java.io.InputStream.read()</code> which can return multiple bytes.&nbsp;
  If the return value is not checked, the caller will not be able to correctly
  handle the case where fewer bytes were read than the caller requested.&nbsp;
  This is a particularly insidious kind of bug, because in many programs,
  reads from input streams usually do read the full amount of data requested,
  causing the program to fail only sporadically.</p>

    
<h3><a name="SR_NOT_CHECKED">RR: Method ignores results of InputStream.skip()</a></h3>


  <p> This method ignores the return value of
  <code>java.io.InputStream.skip()</code> which can skip multiple bytes.&nbsp;
  If the return value is not checked, the caller will not be able to correctly
  handle the case where fewer bytes were skipped than the caller requested.&nbsp;
  This is a particularly insidious kind of bug, because in many programs,
  skips from input streams usually do skip the full amount of data requested,
  causing the program to fail only sporadically. With Buffered streams, however,
  skip() will only skip data in the buffer, and will routinely fail to skip the
  requested number of bytes.</p>

    
<h3><a name="RV_RETURN_VALUE_IGNORED">RV: Method ignores return value</a></h3>


   <p> The return value of this method should be checked. One common
cause of this warning is to invoke a method on an immutable object,
thinking that it updates the object. For example, in the following code 
fragment,</p>
<blockquote>
<pre>
String dateString = getHeaderField(name);
dateString.trim();
</pre>
</blockquote>
<p>the programs seems to be thinking that the trim function will update 
the String referenced by dateString. But since Strings are immutable, the trim
function returns a new String value, which is being ignored here. The code 
should be corrected to: </p>
<blockquote>
<pre>
String dateString = getHeaderField(name);
dataString = dateString.trim();
</pre>
</blockquote>

    
<h3><a name="SA_FIELD_SELF_ASSIGNMENT">SA: Self assignment of field</a></h3>


<p> This method contains a self assignment of a field; e.g.
<pre>
  int x;
  public void foo() {
    x = x;
  }
</pre>
Such assignments are useless, and may indicate a logic error or typo.
</p>

    
<h3><a name="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">SI: Static initializer for class creates instance before all static final fields assigned</a></h3>


<p> The class's static initializer creates an instance of the class
before all of the static final fields are assigned.</p>

    
<h3><a name="SIO_SUPERFLUOUS_INSTANCEOF">SIO: Unnecessary type check done using instanceof operator</a></h3>


<p> Type check performed using the instanceof operator where it can be statically determined whether the object
is of the type requested. </p>

    
<h3><a name="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">SW: Certain swing methods should only be invoked from the Swing event thread</a></h3>


<p>(<a href="http://java.sun.com/developer/JDCTechTips/2003/tt1208.html#1">From JDC Tech Tip</a>): The Swing methods
show(), setVisible(), and pack() will create the associated peer for the frame. 
With the creation of the peer, the system creates the event dispatch thread. 
This makes things problematic because the event dispatch thread could be notifying 
listeners while pack and validate are still processing. This situation could result in 
two threads going through the Swing component-based GUI -- it's a serious flaw that 
could result in deadlocks or other related threading issues. A pack call causes 
components to be realized. As they are being realized (that is, not necessarily 
visible), they could trigger listener notification on the event dispatch thread.</p>


    
<h3><a name="SE_BAD_FIELD">Se: Non-transient non-serializable instance field in serializable class</a></h3>


<p> This Serializable class defines a non-primitive instance field which is neither transient,
Serializable, or <code>java.lang.Object</code>, and does not appear to implement
the <code>Externalizable</code> interface or the
<code>readObject()</code> and <code>writeObject()</code> methods.&nbsp;
Objects of this class will not be deserialized correctly if a non-Serializable
object is stored in this field.</p>

    
<h3><a name="SE_NONFINAL_SERIALVERSIONID">Se: serialVersionUID isn't final</a></h3>


  <p> This class defines a <code>serialVersionUID</code> field that is not final.&nbsp;
  The field should be made final 
	if it is intended to specify
	the version UID for purposes of serialization.</p>

    
<h3><a name="SE_NONLONG_SERIALVERSIONID">Se: serialVersionUID isn't long</a></h3>


  <p> This class defines a <code>serialVersionUID</code> field that is not long.&nbsp;
  The field should be made long
	if it is intended to specify
	the version UID for purposes of serialization.</p>

    
<h3><a name="SE_NONSTATIC_SERIALVERSIONID">Se: serialVersionUID isn't static</a></h3>


  <p> This class defines a <code>serialVersionUID</code> field that is not static.&nbsp;
  The field should be made static
	if it is intended to specify
	the version UID for purposes of serialization.</p>

    
<h3><a name="SE_NO_SUITABLE_CONSTRUCTOR">Se: Class is Serializable but its superclass doesn't define a void constructor</a></h3>


  <p> This class implements the <code>Serializable</code> interface
	and its superclass does not. When such an object is deserialized,
	the fields of the superclass need to be initialized by
	invoking the void constructor of the superclass.
	Since the superclass does not have one,
	serialization and deserialization will fail at runtime.</p>

    
<h3><a name="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">Se: Class is Externalizable but doesn't define a void constructor</a></h3>


  <p> This class implements the <code>Externalizable</code> interface, but does
  not define a void constructor. When Externalizable objects are deserialized,
	they first need to be constructed by invoking the void
	constructor. Since this class does not have one,
	serialization and deserialization will fail at runtime.</p>

    
<h3><a name="SE_NO_SERIALVERSIONID">SnVI: Class is Serializable, but doesn't define serialVersionUID</a></h3>


  <p> This class implements the <code>Serializable</code> interface, but does
  not define a <code>serialVersionUID</code> field.&nbsp; 
  A change as simple as adding a reference to a .class object 
	 will add synthetic fields to the class,
	which will unfortunately change the implicit
	serialVersionUID (e.g., adding a reference to <code>String.class</code>
	will generate a static field <code>class$java$lang$String</code>).
   Also, different source code to bytecode compilers may use different 
   naming conventions for synthetic variables generated for 
   references to class objects or inner classes.
   To ensure interoperability of Serializable across versions,
	consider adding an explicit serialVersionUID.</p>

    
<h3><a name="TESTING">TEST: Testing</a></h3>


<p>This bug pattern is only generated by new, incompletely implemented
bug detectors.</p>

    
<h3><a name="UCF_USELESS_CONTROL_FLOW">UCF: Useless control flow in method</a></h3>


<p> This method contains a useless control flow statement.&nbsp;
Often, this is caused by inadvertently using an empty statement as the
body of an <code>if</code> statement, e.g.:</p>
<pre>
    if (argv.length == 1);
        System.out.println("Hello, " + argv[0]);
</pre>

    
<h3><a name="UI_INHERITANCE_UNSAFE_GETRESOURCE">UI: Usage of GetResource may be unsafe if class is extended</a></h3>


<p>Calling <code>this.getClass().getResource(...)</code> could give
results other than expected if this class is extended by a class in 
another package.</p>

    
<h3><a name="UOE_BAD_ARRAY_COMPARE">UOE: Calls to equals on an Array equates to ==</a></h3>


<p>
This method invokes the .equals(Object o) method on an array. Since arrays do not override the equals
method of Object, calling equals on an array is the same as comparing their addresses. To compare the 
contents of the arrays, use java.util.Array.equals(Object[], Object[]).
</p>
    
    
<h3><a name="UOE_USE_OBJECT_EQUALS">UOE: Calls to equals on a final class that doesn't override Object's version</a></h3>


<p>
This method invokes the .equals(Object o) method on a final class that doesn't override the equals method
in the Object class, effectively making the equals method test for sameness, like ==. Consider adding an .equals
method in this class.
</p>
    
    
<h3><a name="UR_UNINIT_READ">UR: Uninitialized read of field in constructor</a></h3>


  <p> This constructor reads a field which has not yet been assigned a value.&nbsp;
  This is often caused when the programmer mistakenly uses the field instead
  of one of the constructor's parameters.</p>

    
<h3><a name="UWF_UNWRITTEN_FIELD">UwF: Unwritten field</a></h3>


  <p> This field is never written.&nbsp; All reads of it will return the default
value. Check for errors (should it have been initialized?), or remove it if it is useless.</p>

    
<h3><a name="DM_CONVERT_CASE">Dm: Method invokes dubious String.toUpperCase() or String.toLowerCase; use the Locale parameterized version instead</a></h3>


  <p> A String is being converted to upper or lowercase, using the platform's default encoding. This may
      result in improper conversions when used with international characters. Use the </p>
      <table><tr><td>String.toUpperCase( Locale l )</td></tr><tr><td>String.toLowerCase( Locale l )</td></tr></table>
      <p>versions instead.</p>

    
<h3><a name="EI_EXPOSE_REP">EI: Method may expose internal representation by returning reference to mutable object</a></h3>


  <p> Returning a reference to a mutable object value stored in one of the object's fields
  exposes the internal representation of the object.&nbsp; 
	If instances
	are accessed by untrusted code, and unchecked changes to
	the mutable object would compromise security or other
	important properties, you will need to do something different.
  Returning a new copy of the object is better approach in many situations.</p>

    
<h3><a name="EI_EXPOSE_REP2">EI2: Method may expose internal representation by incorporating reference to mutable object</a></h3>


  <p> This code stores a reference to an externally mutable object into the
  internal representation of the object.&nbsp; 
	If instances
	are accessed by untrusted code, and unchecked changes to
	the mutable object would compromise security or other
	important properties, you will need to do something different.
  Storing a copy of the object is better approach in many situations.</p>

    
<h3><a name="FI_PUBLIC_SHOULD_BE_PROTECTED">FI: Finalizer should be protected, not public</a></h3>


  <p> A class's <code>finalize()</code> method should have protected access,
   not public.</p>

    
<h3><a name="EI_EXPOSE_STATIC_REP2">MS: Method may expose internal static state by storing a mutable object into a static field</a></h3>


  <p> This code stores a reference to an externally mutable object into a static
	field. 
	If unchecked changes to
	the mutable object would compromise security or other
	important properties, you will need to do something different.
  Storing a copy of the object is better approach in many situations.</p>

    
<h3><a name="MS_CANNOT_BE_FINAL">MS: Field isn't final and can't be protected from malicious code</a></h3>


  <p> 
 A mutable static field could be changed by malicious code or
        by accident from another package.
	Unfortunately, the way the field is used doesn't allow
	any easy fix to this problem.</p>

    
<h3><a name="MS_EXPOSE_REP">MS: Public static method may expose internal representation by returning array</a></h3>


  <p> A public static method returns a reference to
	an array that is part of the static state of the class. 
	Any code that calls this method can freely modify
	the underlying array.
	One fix is to return a copy of the array.</p>

    
<h3><a name="MS_FINAL_PKGPROTECT">MS: Field should be both final and package protected</a></h3>


 <p>
	A mutable static field could be changed by malicious code or
        by accident from another package.
        The field could be made package protected and/or made final 
	to avoid
        this vulnerability.</p>

    
<h3><a name="MS_MUTABLE_ARRAY">MS: Field is a mutable array</a></h3>


<p> A final static field references an array
	and can be accessed by malicious code or
        by accident from another package.
	This code can freely modify the contents of the array.</p>

    
<h3><a name="MS_MUTABLE_HASHTABLE">MS: Field is a mutable Hashtable</a></h3>


 <p>A final static field references a Hashtable
	and can be accessed by malicious code or
        by accident from another package.
	This code can freely modify the contents of the Hashtable.</p>

    
<h3><a name="MS_OOI_PKGPROTECT">MS: Field should be moved out of an interface and made package protected</a></h3>


<p>
 A final static field that is 
defined in an interface references a mutable
	object such as an array or hashtable.
	This mutable object could 
	be changed by malicious code or
        by accident from another package.
	To solve this, the field needs to be moved to a class
	and made package protected 
	to avoid
        this vulnerability.</p>

    
<h3><a name="MS_PKGPROTECT">MS: Field should be package protected</a></h3>


  <p> A mutable static field could be changed by malicious code or
	by accident.
	The field could be made package protected to avoid
	this vulnerability.</p>

    
<h3><a name="MS_SHOULD_BE_FINAL">MS: Field isn't final but should be</a></h3>


	<p>
 A mutable static field could be changed by malicious code or
        by accident from another package.
        The field could be made final to avoid
        this vulnerability.</p>

    
<h3><a name="2LW_TWO_LOCK_WAIT">2LW: Wait with two locks held</a></h3>


  <p> Waiting on a monitor while two locks are held may cause
  deadlock.
	&nbsp; 
	Performing a wait only releases the lock on the object
	being waited on, not any other locks.
	&nbsp; 
This not necessarily a bug, but is worth examining
  closely.</p>

    
<h3><a name="DC_DOUBLECHECK">DC: Possible double check of field</a></h3>


  <p> This method may contain an instance of double-checked locking.&nbsp;
  This idiom is not correct according to the semantics of the Java memory
  model.&nbsp; For more information, see the web page
  <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"
  >http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>.</p>

    
<h3><a name="IS2_INCONSISTENT_SYNC">IS2: Inconsistent synchronization</a></h3>


  <p> The fields of this class appear to be accessed inconsistently with respect
  to synchronization.&nbsp; This bug report indicates that the bug pattern detector
  judged that
  <ol>
  <li> The class contains a mix of locked and unlocked accesses,</li>
  <li> At least one locked access was performed by one of the class's own methods, and</li>
  <li> The number of unsynchronized field accesses (reads and writes) was no more than
       one third of all accesses, with writes being weighed twice as high as reads</li>
  </ol>
  </p>

  <p> A typical bug matching this bug pattern is forgetting to synchronize
  one of the methods in a class that is intended to be thread-safe.</p>

  <p> You can select the nodes labeled "Unsynchronized access" to show the
  code locations where the detector believed that a field was accessed
  without synchronization.</p>

  <p> Note that there are various sources of inaccuracy in this detector;
  for example, the detector cannot statically detect all situations in which
  a lock is held.&nbsp; Also, even when the detector is accurate in
  distinguishing locked vs. unlocked accesses, the code in question may still
  be correct.</p>

  <p> This description refers to the "IS2" version of the pattern detector,
  which has more accurate ways of detecting locked vs. unlocked accesses
  than the older "IS" detector.</p>

    
<h3><a name="LI_LAZY_INIT_STATIC">LI: Incorrect lazy initialization of static field</a></h3>


<p> This method contains an unsynchronized lazy initialization of a non-volatile static field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
</p>

    
<h3><a name="ML_SYNC_ON_UPDATED_FIELD">ML: Method synchronizes on an updated field</a></h3>


  <p> This method synchronizes on an object 
	references from a mutable field.
	This is unlikely to have useful semantics, since different
threads may be synchronizing on different objects.</p>
  
    
<h3><a name="NN_NAKED_NOTIFY">NN: Naked notify in method</a></h3>


  <p> A call to <code>notify()</code> or <code>notifyAll()</code>
  was made without any (apparent) accompanying
  modification to mutable object state.&nbsp; In general, calling a notify
  method on a monitor is done because some condition another thread is
  waiting for has become true.&nbsp; However, for the condition to be meaningful,
  it must involve a heap object that is visible to both threads.</p>

  <p> This bug does not necessarily indicate an error, since the change to
  mutable object state may have taken place in a method which then called
  the method containing the notification.</p>

    
<h3><a name="NO_NOTIFY_NOT_NOTIFYALL">No: Using notify() rather than notifyAll() in method</a></h3>


  <p> This method calls <code>notify()</code> rather than <code>notifyAll()</code>.&nbsp;
  Java monitors are often used for multiple conditions.&nbsp; Calling <code>notify()</code>
  only wakes up one thread, meaning that the thread woken up might not be the
  one waiting for the condition that the caller just satisfied.</p>

    
<h3><a name="RS_READOBJECT_SYNC">RS: Class's readObject() method is synchronized</a></h3>


  <p> This serializable class defines a <code>readObject()</code> which is
  synchronized.&nbsp; By definition, an object created by deserialization
  is only reachable by one thread, and thus there is no need for
  <code>readObject()</code> to be synchronized.&nbsp; If the <code>readObject()</code>
  method itself is causing the object to become visible to another thread,
  that is an example of very dubious coding style.</p>

    
<h3><a name="RU_INVOKE_RUN">Ru: Invokes run on a thread (did you mean to start it instead?)</a></h3>


  <p> This method explicitly invokes <code>run()</code> on an object.&nbsp;
  In general, classes implement the <code>Runnable</code> interface because
  they are going to have their <code>run()</code> method invoked in a new thread,
  in which case <code>Thread.start()</code> is the right method to call.</p>

    
<h3><a name="SC_START_IN_CTOR">SC: Constructor invokes Thread.start()</a></h3>


  <p> The constructor starts a thread. This is likely to be wrong if
	the class is ever extended/subclassed, since the thread will be started
	before the subclass constructor is started.</p>

    
<h3><a name="SP_SPIN_ON_FIELD">SP: Method spins on field</a></h3>


  <p> This method spins in a loop which reads a field.&nbsp; The compiler
  may legally hoist the read out of the loop, turning the code into an
  infinite loop.&nbsp; The class should be changed so it uses proper
  synchronization (including wait and notify calls).</p>

    
<h3><a name="UG_SYNC_SET_UNSYNC_GET">UG: Unsynchronized get method, synchronized set method</a></h3>


  <p> This class contains similarly-named get and set
  methods where the set method is synchronized and the get method is not.&nbsp;
  This may result in incorrect behavior at runtime, as callers of the get
  method will not necessarily see a consistent state for the object.&nbsp;
  The get method should be made synchronized.</p>

    
<h3><a name="UW_UNCOND_WAIT">UW: Unconditional wait in method</a></h3>


  <p> This method contains a call to <code>java.lang.Object.wait()</code> which
  is not guarded by conditional control flow.&nbsp; If the condition that
  the method intends to wait for has already happened, the thread could
  wait indefinitely.</p>

    
<h3><a name="VO_VOLATILE_REFERENCE_TO_ARRAY">VO: A volatile reference to an array doesn't treat the array elements as volatile</a></h3>


<p>This declares a volatile reference to an array, which might not be what
you want. With a volatile reference to an array, reads and writes of
the reference to the array are treated as volatile, but the array elements
are non-volatile. To get volatile array elements, you will need to use
one of the atomic array classes in java.util.concurrent (provided
in Java 5.0).</p>

    
<h3><a name="WS_WRITEOBJECT_SYNC">WS: Class's writeObject() method is synchronized but nothing else is</a></h3>


  <p> This class has a <code>writeObject()</code> method which is synchronized;
  however, no other method of the class is synchronized.</p>

    
<h3><a name="WA_NOT_IN_LOOP">Wa: Wait not in loop in method</a></h3>


  <p> This method contains a call to <code>java.lang.Object.wait()</code> 
  which is not in a loop.&nbsp; If the monitor is used for multiple conditions,
  the condition the caller intended to wait for might not be the one
  that actually occurred.</p>

    
<h3><a name="DM_BOOLEAN_CTOR">Dm: Method invokes dubious Boolean constructor; use Boolean.valueOf(...) instead</a></h3>


  <p> Creating new instances of <code>java.lang.Boolean</code> wastes
  memory, since <code>Boolean</code> objects are immutable and there are
  only two useful values of this type.&nbsp; Use the <code>Boolean.valueOf()</code>
  method to create <code>Boolean</code> objects instead.</p>

    
<h3><a name="DM_BOXED_PRIMITIVE_TOSTRING">Dm: Method allocates a boxed primitive just to call toString</a></h3>


  <p>A boxed primitive is allocated just to call toString(). It is more effective to just use the static
  form of toString which takes the primitive value. So,</p>
  <table>
     <tr><th>Replace...</th><th>With this...</th></tr>
     <tr><td>new Integer(1).toString()</td><td>Integer.toString(1)</td></tr>
     <tr><td>new Long(1).toString()</td><td>Long.toString(1)</td></tr>
     <tr><td>new Float(1.0).toString()</td><td>Float.toString(1.0)</td></tr>
     <tr><td>new Double(1.0).toString()</td><td>Double.toString(1.0)</td></tr>
     <tr><td>new Byte(1).toString()</td><td>Byte.toString(1)</td></tr>
     <tr><td>new Short(1).toString()</td><td>Short.toString(1)</td></tr>
     <tr><td>new Boolean(true).toString()</td><td>Boolean.toString(true)</td></tr>
  </table>

    
<h3><a name="DM_GC">Dm: Explicit garbage collection; extremely dubious except in benchmarking code</a></h3>


  <p> Code explicitly invokes garbage collection.
  Except for specific use in benchmarking, this is very dubious.</p>
  <p>In the past, situations where people have explicitly invoked 
  the garbage collector in routines such as close or finalize methods
  has led to huge performance black holes. Garbage collection 
	can be expensive. Any situation that forces hundreds or thousands
	of garbage collections will bring the machine to a crawl.</p>

    
<h3><a name="DM_NEW_FOR_GETCLASS">Dm: Method allocates an object, only to get the class object</a></h3>


  <p>This method allocates an object just to call getClass() on it, in order to 
  retrieve the Class object for it. It is simpler to just access the .class property of the class.</p>

    
<h3><a name="DM_NEXTINT_VIA_NEXTDOUBLE">Dm: Use the nextInt method of Random rather than nextDouble to generate a random integer</a></h3>


  <p>If r is a java.util.Random, you can generate a random number from 0 to n-1
using r.nextInt(n) Rather than using (int)(r.nextDouble() * n).
</p>

    
<h3><a name="DM_STRING_CTOR">Dm: Method invokes dubious new String(String) constructor; just use the argument</a></h3>


  <p> Using the <code>java.lang.String(String)</code> constructor wastes memory
  because the object so constructed will be functionally indistinguishable
  from the <code>String</code> passed as a parameter.&nbsp; Just use the
  argument <code>String</code> directly.</p>

    
<h3><a name="DM_STRING_EMPTY_EQUALS">Dm: Method invokes dubious String.equals(""); use String.length() == 0 instead</a></h3>


  <p> An object is compared to the empty String object using the equals() method here.
      Checking that the String object's length is zero may be faster, and removes String constants from the class file.</p>

    
<h3><a name="DM_STRING_TOSTRING">Dm: Method invokes toString() method on a String; just use the String</a></h3>


  <p> Calling <code>String.toString()</code> is just a redundant operation.
  Just use the String.</p>

    
<h3><a name="DM_STRING_VOID_CTOR">Dm: Method invokes dubious new String() constructor; just use ""</a></h3>


  <p> Creating a new <code>java.lang.String</code> object using the
  no-argument constructor wastes memory because the object so created will
  be functionally indistinguishable from the empty string constant
  <code>""</code>.&nbsp; Java guarantees that identical string constants
  will be represented by the same <code>String</code> object.&nbsp; Therefore,
  you should just use the empty string constant directly.</p>

    
<h3><a name="FI_EMPTY">FI: Empty finalizer should be deleted</a></h3>


  <p> Empty <code>finalize()</code> methods are useless, so they should
  be deleted.</p>

    
<h3><a name="FI_USELESS">FI: Finalizer does nothing but call superclass finalizer</a></h3>


  <p> The only thing this <code>finalize()</code> method does is call
  the superclass's <code>finalize()</code> method, making it
  redundant.&nbsp; Delete it.</p>

    
<h3><a name="ITA_INEFFICIENT_TO_ARRAY">ITA: Method uses toArray() with zero-length array argument</a></h3>


<p> This method uses the toArray() method of a collection derived class, and passes
in a zero-length prototype array argument.  It is more efficient to use 
<pre>myCollection.toArray(new Foo[myCollection.size()])</pre>
If the array passed in is big enough to store all of the
elements of the collection, then it is populated and returned
directly. This avoids the need to create a second array
(by reflection) to return as the result.</p>

    
<h3><a name="SBSC_USE_STRINGBUFFER_CONCATENATION">SBSC: Method concatenates strings using + in a loop</a></h3>


<p> The method seems to be building a String using concatenation in a loop.
In each iteration, the String is converted to a StringBuffer/StringBuilder, 
	appended to, and converted back to a String.
	This can lead to a cost quadractic in the number of iterations,
	as the growing string is recopied in each iteration. </p>
	
<p>Better performance can be obtained by using 
a StringBuffer (or StringBuilder in Java 1.5) explicitly.</p>

<p> For example:</p>
<pre>
  // This is bad
  String s = "";
  for (int i = 0; i &lt; field.length; ++i) {
    s = s + field[i];
  }

  // This is better
  StringBuffer buf = new StringBuffer();
  for (int i = 0; i &lt; field.length; ++i) {
    buf.append(field[i]);
  }
  String s = buf.toString();
</pre>

    
<h3><a name="SIC_INNER_SHOULD_BE_STATIC">SIC: Should be a static inner class</a></h3>


  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
  made into a <em>static</em> inner class.</p>

    
<h3><a name="SIC_INNER_SHOULD_BE_STATIC_ANON">SIC: Could be refactored into a named static inner class</a></h3>


  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
  made into a <em>static</em> inner class. Since anonymous inner
classes cannot be marked as static, doing this will requiring refactoring
the inner class so that it is a named inner class.</p>

    
<h3><a name="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">SIC: Could be refactored into a static inner class</a></h3>


  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it except during construction of the 
inner object.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
  made into a <em>static</em> inner class. Since the reference to the
	outer object is required during construction of the inner instance,
	the inner class will need to be refactored so as to 
	pass  a reference to the outer instance to the constructor
	for the inner class.</p>

    
<h3><a name="SS_SHOULD_BE_STATIC">SS: Unread field: should this field be static?</a></h3>


  <p> This class contains an instance final field that
	is initialized to a compile-time static value.
	Consider making the field static.</p>

    
<h3><a name="UPM_UNCALLED_PRIVATE_METHOD">UPM: Private method is never called</a></h3>


<p> This private method is never called. Although it is
possible that the method will be invoked through reflection,
it is more likely that the method is never used, and should be
removed.
</p>


<h3><a name="URF_UNREAD_FIELD">UrF: Unread field</a></h3>


  <p> This field is never read.&nbsp; Consider removing it from the class.</p>

    
<h3><a name="UUF_UNUSED_FIELD">UuF: Unused field</a></h3>


  <p> This field is never used.&nbsp; Consider removing it from the class.</p>

    
<h3><a name="WMI_WRONG_MAP_ITERATOR">WMI: Inefficient use of keySet iterator instead of entrySet iterator</a></h3>


<p> This detector looks for accessing the value of a Map entry, using a key that was retrieved from
a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the 
Map.get(key) lookup.

        
<h3><a name="NM_CLASS_NAMING_CONVENTION">Nm: Class names should start with an upper case letter</a></h3>


  <p> Class names should be nouns, in mixed case with the first letter of each internal word capitalized. Try to keep your class names simple and descriptive. Use whole words-avoid acronyms and abbreviations (unless the abbreviation is much more widely used than the long form, such as URL or HTML).
</p>

    
<h3><a name="NM_FIELD_NAMING_CONVENTION">Nm: Field names should start with an lower case letter</a></h3>


  <p> 
Names of fields that are not final should be in mixed case with a lowercase first letter and the first letters of subsequent words capitalized. 
</p>

    
<h3><a name="NM_METHOD_NAMING_CONVENTION">Nm: Method names should start with an lower case letter</a></h3>


  <p> 
Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.
</p>

    
<h3><a name="REC_CATCH_EXCEPTION">REC: java.lang.Exception is caught when Exception is not thrown</a></h3>

  
  <p>
  This detector looks for try-catch blocks where there is a catch block for Exception, but Exception is not
  thrown within the try block, and RuntimeException is not explicitly caught.  It is a common bug pattern to
  say try { ... } catch (Exception e) { something } as a shorthand for catching a number of types of exception
  each of whose catch blocks is identical, but this constract also accidentally catches RuntimeException as well,
  masking potential bugs.
  </p>
  
	  
<h3><a name="SA_LOCAL_SELF_ASSIGNMENT">SA: Self assignment of local variable</a></h3>


<p> This method contains a self assignment of a local variable; e.g.
<pre>
  public void foo() {
    int x = 3;
    x = x;
  }
</pre>
Such assignments are useless, and may indicate a logic error or typo.</p>

    
<h3><a name="SF_SWITCH_FALLTHROUGH">SF: A switch statement found where one case falls thru to the next case</a></h3>


  <p> This method contains a switch statement where one case branch will fall thru to the next case.
  Usually you need to end this case with a break or return.</p>

    


<hr> <p> 
<script language="JavaScript"> 
<!---//hide script from old browsers 
document.write( "Last updated "+ document.lastModified + "." ); 
//end hiding contents ---> 
</script> 
<p> Send comments to <a class="sidebar" href="mailto:daveho@cs.umd.edu">daveho@cs.umd.edu</a> 
<p> 
<A href="http://sourceforge.net"><IMG src="http://sourceforge.net/sflogo.php?group_id=96405&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo" /></A>
</td></tr></table>
</body></html>
