<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_04) on Wed Mar 24 01:54:06 GMT-05:00 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
com.dautelle.realtime (JADE v6.0 API)
</TITLE>

<META NAME="keywords" CONTENT="com.dautelle.realtime package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="com.dautelle.realtime (JADE v6.0 API)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

                <b><a href=http://jade.dautelle.com>JADE v6.0</a></b>
            </EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/dautelle/physics/models/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../com/dautelle/util/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package com.dautelle.realtime
</H2>
 Provides real-time <A HREF="../../../com/dautelle/realtime/Context.html" title="class in com.dautelle.realtime"><CODE>Context</CODE></A> for higher
    performance and higher predictability of Java bytecode execution.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/Realtime.html" title="interface in com.dautelle.realtime">Realtime</A></B></TD>
<TD> This interface identifies classes with higher performance and higher
     predictability when their methods are executed within 
     a (@link PoolContext}.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/ArrayPool.html" title="class in com.dautelle.realtime">ArrayPool</A></B></TD>
<TD> This class provides static methods to return <A HREF="../../../com/dautelle/realtime/ObjectPool.html" title="class in com.dautelle.realtime"><CODE>ObjectPool</CODE></A> for
     array of any type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/ConcurrentContext.html" title="class in com.dautelle.realtime">ConcurrentContext</A></B></TD>
<TD> This class represents a concurrent context; it is used to accelerate
     execution of concurrent algorithms on multi-processors systems.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/Context.html" title="class in com.dautelle.realtime">Context</A></B></TD>
<TD> This class represents a real-time context (thread-based).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/HeapContext.html" title="class in com.dautelle.realtime">HeapContext</A></B></TD>
<TD> This class represents a heap context; it is used to allocate objects
     from the heap pool (always safe).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/LocalContext.html" title="class in com.dautelle.realtime">LocalContext</A></B></TD>
<TD> This class represents a local context; it is used to define
     inheritable environment settings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/LocalContext.Variable.html" title="class in com.dautelle.realtime">LocalContext.Variable</A></B></TD>
<TD>This class represents a <A HREF="../../../com/dautelle/realtime/LocalContext.html" title="class in com.dautelle.realtime"><CODE>LocalContext</CODE></A> variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/ObjectFactory.html" title="class in com.dautelle.realtime">ObjectFactory</A></B></TD>
<TD> This class represents an object factory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/ObjectPool.html" title="class in com.dautelle.realtime">ObjectPool</A></B></TD>
<TD>This abstract class represents an object pool managed by a 
 <A HREF="../../../com/dautelle/realtime/PoolContext.html" title="class in com.dautelle.realtime"><CODE>PoolContext</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/PoolContext.html" title="class in com.dautelle.realtime">PoolContext</A></B></TD>
<TD> This class represents a pool context; it is used to reduce
     memory allocation and its "evil-brother" garbage collection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/RealtimeObject.html" title="class in com.dautelle.realtime">RealtimeObject</A></B></TD>
<TD> This class provides a default implementation of the <A HREF="../../../com/dautelle/realtime/Realtime.html" title="interface in com.dautelle.realtime"><CODE>Realtime</CODE></A> 
     interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/RealtimeObject.Factory.html" title="class in com.dautelle.realtime">RealtimeObject.Factory</A></B></TD>
<TD>This abstract class represents the factory responsible for the 
 creation of <A HREF="../../../com/dautelle/realtime/RealtimeObject.html" title="class in com.dautelle.realtime"><CODE>RealtimeObject</CODE></A> instances.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Exception Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../com/dautelle/realtime/ConcurrentException.html" title="class in com.dautelle.realtime">ConcurrentException</A></B></TD>
<TD>This class encapsulates errors or exceptions raised during the execution
 of concurrent threads (<A HREF="../../../com/dautelle/realtime/ConcurrentException.html" title="class in com.dautelle.realtime"><CODE>ConcurrentException</CODE></A> are raised upon exit of
 the <A HREF="../../../com/dautelle/realtime/ConcurrentContext.html" title="class in com.dautelle.realtime"><CODE>ConcurrentContext</CODE></A>).</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package com.dautelle.realtime Description
</H2>

<P>
<p> Provides real-time <A HREF="../../../com/dautelle/realtime/Context.html" title="class in com.dautelle.realtime"><CODE>Context</CODE></A> for higher
    performance and higher predictability of Java bytecode execution.</p>
  <p> The rationale for this package is:
  <ul>
      <li> Allocating/Initializing memory is not particularly fast.</li>
      <li> Concurrent programming using new threads is cumbersome, inefficient
           for low-level libraries (too much overhead) and synchronization
           can be tricky.</li>
      <li> Garbage collection occurs only when allocating memory.</li>
  </ul></p>
<p> Therefore, if "new" objects are ready to be used (<code>PoolContext</code>)
    and concurrency is encapsulated (<code>ConcurrentContext</code>),
    then code execution:
  <ol>
      <li> Is faster (see <a href="http://jade.dautelle.com/doc/benchmark.txt">benchmark</a>)!</li>
      <li> Is not interrupted by garbage collection (more predictable scheduling).</li>
      <li> Has no assignment constraint as all objects originate from the heap
           (Ref. <A href="http://www.jcp.org/jsr/detail/1.jsp">RTSJ</A>
           assignment rules where heap objects cannot refer to scoped objects).</li>
      <li> Is distributed over multiple CPUs. Core routines implementations may
           take advantage of concurrent algorithms. For example, a simple quick-sort
           is up to <b>twice faster</b> on Intel Pentium 4 with Hyper-Threading Technology
           (Hyper-Threading doubles the number of executing threads per processor).</li>
  </ol></p>

</a>
<h2><a name="FAQ">Real-time facility FAQ:</a></h2>
<ol>
    <li><b>Can you explain a little how the PoolContext works? 
    I looked at the example code in the Javadoc, and I'm still a little fuzzy on where and what 
    the "magic" is that it performs...</b>
    <p> 
    The basic idea is to associate objects pools to Java threads. 
    These pools can be nested, with the heap being the root of all pools.
    You may consider pools' objects as part of the thread stack memory, with pools being pushed and 
    popped as the thread enters/exits <A HREF="../../../com/dautelle/realtime/PoolContext.html" title="class in com.dautelle.realtime"><CODE>PoolContext</CODE></A>.
    To allocate from its "stack", a thread needs to execute within a pool context
    and create "new" objects using <A HREF="../../../com/dautelle/realtime/ObjectFactory.html" title="class in com.dautelle.realtime"><CODE>object factories</CODE></A>
    (the "new" keyword always allocates on the heap, JADE does not/cannot change 
    the Java Virtual Machine behavior). This mechanism is similar to the allocation
    on the stack of locally declared primitive variables, but now extended to
    non-primitive objects.
    </p> 
    <p><i> Note: Classes encapsulating calls to object factories within
                their factory methods (e.g. <code>valueOf(...)</code>) and 
                whose methods do not allocate directly on the heap are known
                as "real-time compliant".</i></p>
    </li><p></p>

    <li><b>How do I make my own classes real-time compliant?</b>
    <p> The simplest way is to extend <A HREF="../../../com/dautelle/realtime/RealtimeObject.html" title="class in com.dautelle.realtime"><CODE>RealtimeObject</CODE></A>
        and use a factory or the <A HREF="../../../com/dautelle/realtime/RealtimeObject.html#spawn()"><CODE>spawn</CODE></A> method 
        to create new instances. For example:<pre>
    public final class Coordinates extends RealtimeObject {
        private double latitude;
        private double longitude;        
        static final Factory FACTORY = new Factory() {
              public Object create() {
                  return new Coordinates();
              }
        };
       private Coordinates() {} 
       public static Coordinates valueOf(double latitude, double longitude) {
           Coordinates c = (Coordinates) FACTORY.currentPool().next();
           c.latitude = latitude;
           c.longitude = longitude;
           return c;
       }
    }</pre>
    Et voila! Your class is now real-time compliant!
    <p> The following code shows the accelerating effect of pool contexts.<pre>
     public static void main(String[] args) {
         Coordinates[] vertices = new Coordinates[1000000];
         for (int i=0; i < 10; i++) {     
             long time = System.currentTimeMillis();
             PoolContext.enter();
             try {
                 for (int j = 0; j < vertices.length; j++) {
                     vertices[j] = Coordinates.valueOf(i, j);
                 }
             }finally {
                 PoolContext.exit();
             }
             time = System.currentTimeMillis()-time;
             System.out.println("Time = " + time);
         }
     }</pre>
        The first iteration is always slower as objects are allocated on the heap
        and populate the pool.<br> 
        Subsequent iterations are not only faster but 
        very consistent in time as no memory allocation/garbage collection 
        will ever occur.<pre> 
  Time = 1547
  Time = 93
  Time = 94
  Time = 94
  Time = 94
  Time = 93
  Time = 94
  Time = 94
  Time = 93
  Time = 94</pre>
  <i>Note: Real-time threads may perform a first iteration at initialization. 
    This also ensures that all necessary classes are initialized and the critical
    loop can execute in a very predictable time.</i></p>
    
  <p> The same program allocating directly on the heap (e.g. <code>new Coordinates(i, j)</code>)
     produces the following result:<pre>
  Time = 937
  Time = 703
  Time = 1078
  Time = 641
  Time = 656
  Time = 656
  Time = 641
  Time = 671
  Time = 641
  Time = 656</pre> 
  Not only code execution is <b>6x</b> time slower but there is much 
  more fluctuation in the execution time due to GC.</p>
    </li><p></p>
    
    <li><b>As a rule, I am skeptical of classes that pool small objects. 
     At one time (5 years ago) it was a big win. Over time, the advantage has 
     diminished as garbage collectors improve. Object pools can make it much more
     difficult for the garbage collector to do its job efficiently, and can have
     adverse effects on footprint. (Joshua Bloch) </b>
    <p> Pool context is a simple and transparent way to make your methods "clean" (no garbage 
        generated), it has also the side effect of making your methods faster 
        and more time-predictable. If all your methods are "clean" then your whole 
        application is "clean", faster and more time-predictable (aka real-time).</p>
    <p> Although pool contexts may "clean" a big "mess" in record
        time (recycling is done all at once, almost instantaneously and way 
        faster than GC). Still you may run into memory problems if you let the
        "mess" gets out of control!</p>
    <p> Now, not all your methods need to be executed
        in a pool context, only the "dirty" ones (the one generating a lot of 
        garbage).<pre>
    // Karatsuba multiplication. 
    // A lot of intermediate calculations, use of PoolContext recommended.
    LargeInteger product(LargeInteger a, LargeInteger b) {
       PoolContext.enter(); // Enters local pool.
       try {
           LargeInteger aR = ...;
           LargeInteger aL = ...;
           LargeInteger bR = ...;
           LargeInteger bL = ...;
           LargeInteger x1 = aL.multiply(bL);
           LargeInteger x2 = aR.multiply(bR);
           LargeInteger x3 = aL.add(bL).multiply(aR.add(bR));
           // Calculates x1.shift(n) + (x3 - x1 - x2).shift(n / 2) + x2;
           LargeInteger result = ...
           return (LargeInteger) result.export(); 
       } finally {
           PoolContext.exit(); // Exits local pool, objects recycled all at once,
       }                       // regardless of the number of objects allocated.
       </pre>
       Iterations are often good candidates for pool context as 
       they typically generate a lot of garbage.<pre>
   public Matrix pow(int exp) { // exp > 0
       PoolContext.enter(); 
       try { 
           Matrix pow2 = this;
           Matrix result = null;
           while (exp >= 1) { // Iteration.
                if ((exp & 1) == 1) {
                   result = (result == null) ? pow2 : result.multiply(pow2);
                }
                pow2 = pow2.multiply(pow2);
                exp >>>= 1;
           } 
           return (Matrix) result.export();
       } finally {
            PoolContext.exit();
       }
    }</pre></p>
    For the very "dirty" (e.g. very long interations), one pool context
    might not be enough and may cause memory overflow. You might have
    to break down the iteration loop and use inner contexts.<pre>
    Product[] products = ... // Very long array.
    Money total = Money.ZERO;
    PoolContext.enter();
    try { 
        for (int i=0; i < products.length;) {
            PoolContext.enter(); // Inner pool context.
            try {
                // Processes up to 1024 products at a time.
                for (int j=0; (j < 1024) && (i < products.length); j++) {
                    total = total.add(products[i++].price());
                } 
                total = (Money) total.export();
            } finally {
                PoolContext.exit();
            }
        }
        total = (Money) total.export();
    } finally {
        PoolContext.exit();
    }</pre>
    Finally, individual recycling is possible for methods having access 
    to the object pool. It is the case for member methods (ref.
    <b>protected</b> method <A HREF="../../../com/dautelle/realtime/RealtimeObject.html#recycle()"><CODE>recycle</CODE></A>) or
    methods having direct access to the <A HREF="../../../com/dautelle/realtime/ObjectFactory.html" title="class in com.dautelle.realtime"><CODE>factory</CODE></A> 
    instance. The <A HREF="../../../com/dautelle/realtime/ArrayPool.html" title="class in com.dautelle.realtime"><CODE>ArrayPool</CODE></A>
    class has its pools public and therefore allows for individual recycling of any
    array.<pre>
    // Array Pool.
    ObjectPool pool = ArrayPool.charArray(1024);
    char[] buffer = (char[]) pool.next(); // New or recycled.
    for (int i = reader.read(buffer, 0, buffer.length); i > 0;) {
        ...
    } 
    pool.recycle(buffer); // Puts back buffer into its pool or do nothing if the pool
                          // represents the heap (e.g. thread executing in the default
                          // heap context) as only GC can recycle then.
    
    // Member method (use of <b>protected</b> recycle method).
    public LargeInteger gcd(LargeInteger that) {
        LargeInteger a = this.abs();
        LargeInteger b = that.abs();
        while (!b.isZero()) {
            LargeInteger tmp = a.divide(b);
            LargeInteger c = tmp.getRemainder();
            tmp.recycle(); // Individual recycling affects only objects
            a.recycle();   // belonging to the current pool context.
            a = b;
            b = c;
        }
        return a;
    }</pre>    
    <i> Note: Pool allocation/recycling is effective only if the current thread
    executes within a pool context; otherwise heap allocations are being performed and
    GC does the recycling.</i></p>
    </li><p></p>

    <li><b>Are not PoolContext inherently unsafe (e.g. immutable objects changing
        suddenly values) ?</b>
    <p> No, as long as you <A HREF="../../../com/dautelle/realtime/Realtime.html#export()"><CODE>export</CODE></A> the
        objects which might be referenced outside of the pool context,
        <b>immutable objects stay immutable!</b> Furthermore, you do not have to 
        worry about thread synchronization as pool objects are thread-local.
        The "export" rule guarantees that global objects (shared by all threads)
        end up being exported to the heap (root context), with GC doing the 
        recycling (if necessary, see next question).
        It is also possible to export to the heap directly either by executing
        within an inner <A HREF="../../../com/dautelle/realtime/HeapContext.html" title="class in com.dautelle.realtime"><CODE>HeapContext</CODE></A> or 
        by <A HREF="../../../com/dautelle/realtime/Realtime.html#toHeap()"><CODE>moving</CODE></A> pool objects to the heap.
        In truth, pool contexts promote the use of immutable objects 
        (as their allocation cost is being significantly reduced), reduces thread 
        interaction (e.g. race conditions) and often lead to safer, faster and more
        robust applications.</p>
    </li><p></p>

    <li><b>Our application is hard real-time, we cannot afford to run GC 
        ever, can we still use JADE ?</b>
    <p> <b>A resounding Yes!</b> The easiest way is to ensure that all your threads
         run in a pool context, only static constants are exported to 
         the heap and your system state can be updated without allocating new
         objects (e.g. <code>StringBuffer</code> instead of <code>String</code>
         or <A HREF="../../../com/dautelle/util/FastMap.html" title="class in com.dautelle.util"><CODE>FastMap</CODE></A> instead of <code>HashMap</code>)!
         For concurrent access/modification to the system state, the use of 
         <A HREF="../../../com/dautelle/util/ReentrantLock.html" title="class in com.dautelle.util"><CODE>ReentrantLock</CODE></A> is usually recommended.
         May seem like a lot, but don't forget with JADE, <b>90%</b> of your application code
         is oblivious of the garbage collection issue, provided that the "new" keyword
         is prohibited and replaced by factory methods. JADE's classes are 
         real-time compliant (use <A HREF="../../../com/dautelle/realtime/ObjectFactory.html" title="class in com.dautelle.realtime"><CODE>object factories</CODE></A>
         for new allocations). Some JDK library classes
         may create temporary objects on the heap and therefore should be avoided
         or replaced by "cleaner" classes (e.g. 
         <A HREF="../../../com/dautelle/util/TypeFormat.html" title="class in com.dautelle.util"><CODE>TypeFormat</CODE></A> for parsing/formatting 
         of primitive types).</p>
    <IMG src="doc-files/realtime.jpg">
    </li><p></p>

    <li><b>Can I use <code>PoolContext</code> with the Java core library?</b>
    <p> Yes, although these library calls will not execute faster (Java library
        always uses the heap context). Nonetheless, you may significantly 
        accelerate your application and reduce garbage by using object factories
        to produce instances of Java library classes and by executing your code 
        within a pool context.<pre>
    static final ObjectFactory STRING_BUFFER_FACTORY = new ObjectFactory() {
        public Object create() {
            return new StringBuffer(26);
        }
    };
    // Clean. Only one object allocated: The String being returned.
    public String toString() { 
        ObjectPool pool = STRING_BUFFER_FACTORY.currentPool(); // Would be the heap if not in a PoolContext.
        StringBuffer sb = (StringBuffer) pool.next();
        ... // Use sb to format this object.
        pool.recycle(sb); // Recycles sb (has no effect if heap pool, only GC can recycle then).
        return sb.toString(); // Safe, sb has not been reused yet, pools are thread local.
    }</pre></p>
    </li><p></p>

    <li><b>What performance gain can I expect by using a pool context?</b>
    <p> Classes avoiding dynamic memory allocation are significantly faster.
        For example, our <A HREF="../../../com/dautelle/xml/sax/RealtimeParser.html" title="class in com.dautelle.xml.sax"><CODE>real-time XML parser</CODE></A>
        is <b>3-5x</b> faster than conventional SAX2 parsers. To avoid synchronization 
        issues, it is often easier to allocate new objects. Other techniques such 
        as the "returnValue" parameter are particularly ugly and unsafe
        as they require mutability. JADE's real-time facility promotes the dynamic 
        creation of immutable objects as these object creations are fast and have no adverse
        effect on garbage collection. Basically, with pool contexts, <b> the CPU is 
        busy doing the "real thing" not "memory management"!</b></p>
    <p> The cost of allocating on the heap is somewhat <b>proportional
        to the size</b> of the object being allocated. By avoiding or postponing this
        cost you can drastically increase the execution speed.<b> The largest objects
        benefit the most.</b> For example, our public domain <code>FastString</code>
        can be <b>several orders of magnitude faster</b> than <code>java.lang.String</code>
       (see <a href="http://jade.dautelle.com/doc/benchmark.txt">benchmark</a>).
        Not surprising when you know that even "empty" <code>Strings</code> 
        take 40 bytes of memory which have to be initialized and garbage collected!</p>
    <p> Recycling objects is way more powerful than just recycling memory (aka GC).
        For example, our <A HREF="../../../com/dautelle/util/FastMap.html" title="class in com.dautelle.util"><CODE>FastMap</CODE></A> is 
        a complex object using preallocated linked lists. It is fast but costly
        to build. Nevertheless, in a pool context it can be used as a throw-away map
        because <b>the construction cost is then reduced to nothing!</b></p>
    </li><p></p>

    <li><b>Virtual Machines with concurrent garbage collection are becoming more
           and more popular. Do we still need a real-time facility?</b>
    <p> Concurrent garbage collection is a perfect complement to JADE real-time facility
        (Ref. <a href="http://developer.java.sun.com/developer/technicalArticles/Programming/turbo/">
        New Hotspot<sup>TM</sup> JVM</a>). In particular, without preemptable
        garbage collection we cannot ensure that periodic real-time threads start on-time.</p>
    <p> For real-time applications, the advantages of the facility are threefold:
        <ul><li> Faster execution. Objects have already been allocated and
                 initialized (increases responsiveness).</li>
            <li> <code>PoolContext</code> limit/eliminate garbage and therefore
                 reduce the clean-up effort by the system (maximizes processing efficiency).</li>
            <li> <code>ConcurrentContext</code> are easy to use and have almost no
                 overhead. They can be used to accelerate low-level operations
                 on multi-processors systems (automatic low-level CPU repartition).</li>
        </ul></p>
   <p>  Unlike, the Real-Time Specification for Java (RTSJ) whose memory model
        becomes obsolete with the coming of concurrent garbage collection
        (who wants to use a slower memory model to achieve predictability when
        predictability can be achieved without?). I expect that
        the <b><i>"turbo"</i> effect</b> provided by our real-time facility will
        attract more and more real-time applications. Especially when preemptable
        garbage collection makes Java a satisfactory platform for real-time systems.
        </li><p></p>
</ol>
<P>

<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

                <b><a href=http://jade.dautelle.com>JADE v6.0</a></b>
            </EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/dautelle/physics/models/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../com/dautelle/util/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

               <i>Copyright &#169; 2004 Jean-Marie Dautelle.</i>
            
</BODY>
</HTML>
